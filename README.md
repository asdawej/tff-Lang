# tff-Lang a2.0.0

- [tff-Lang a2.0.0](#tff-lang-a200)
  - [编译指南](#编译指南)
  - [头文件有向图](#头文件有向图)
  - [示例代码](#示例代码)

## 编译指南

[CompileGuide](./CompileGuide.md)

## 头文件有向图

[IncludeGraph](./IncludeGraph.md)

## 示例代码

一个计算加法的代码, 根据输出的两个数, 输出它们的和及这两个加数.

- 这段代码大量使用了一种语法糖——**圆括号转义**, 它有两种用法:
  - 一种是将括号内的字符串根据预定的规则转化为特殊对象, 比如 `(add)` 转译为内置加法函数, `(stdin)` 和 `(stdout)` 转义为标准输入流和标准输出流;
  - 另一种是将圆括号内部的整数转义为三进制表达式, 如第一行的 `(-1)` 表示将内置加法函数委托在 `F` 地址上. 这种用法主要是为了便于阅读.

- 从上往下依次为:
  - 将内置加法函数委托在 `-1 = F` 地址上(委托的过程实际是包装的过程).
  - 从标准输入流依次读取 `2` 个 Tryte 并写入以 `T` 地址为开头的一段内存.
  - 运行 `-1 = F` 地址上委托的加法函数, 这个函数形如 `N = T + TN`.
  - 从 `N` 地址开始读取 `3` 个 Tryte 并依次写入标准输出流.

```python
5 {(-1), (add)}
7 {(stdin), T, (2)}
4 {(-1)}
7 {N, (stdout), (3)}
```

一个简易循环的例子. 通过你的输入来决定是否继续循环.

- 从上往下依次为:
  - 构建一个代码树并委托于 `F` 地址, 内容为从 `T` 地址读取 `1` 个 Tryte 并写入标准输出流.
  - 构建一个代码树并委托于 `N` 地址. 首先从标准输入流读取 `1` 个 Tryte 并写入 `T` 地址; 然后, 根据 `T` 地址的值, 如果是正值则继续执行 `N` 地址的委托 (相当于 `continue`), 如果是负值则执行 `F` 地址的委托 (输出 `T` 地址的值然后终止), 如果是 `N` 则直接终止.

```python
5 {
    F,
    {7 {T, (stdout), (1)}}
}
5 {
    N,
    {
        7 {(stdin), T, (1)} # 循环体
        6 {
            T2, # 循环条件
            {4 {N}},
            {4 {F}}
        }
    }
}
4 {N}
```